sourceSets.main{
    java.srcDirs = ['src/']
}

sourceCompatibility = 17
targetCompatibility = 17

import arc.files.*
import arc.func.Func2
import arc.struct.IntMap
import arc.struct.ObjectMap
import arc.struct.OrderedMap
import arc.struct.Seq
import arc.util.Log
import arc.util.io.PropertiesUtils

final def dexedJar = (project(':main').tasks.dex as Jar).archiveFile.get().asFile
final def distJar = (project(':main').tasks.deploy as Jar).archiveFile.get().asFile
final def regularJar = (project(':main').tasks.jar as Jar).archiveFile.get().asFile

final def usedClasspath =
    taskNames.contains('main:dex') ? dexedJar :
    taskNames.contains('main:deploy') ? distJar :
    dexedJar.exists() ? dexedJar :
    distJar.exists() ? distJar :
    regularJar

dependencies{
    if(
    !usedClasspath.exists() || toolRecompile ||
        taskNames.contains('main:deploy') || taskNames.contains('main:dex')
    ){
        implementation project(':main')
        if(taskNames.contains('tools:proc')) println 'Compiling :main project before processing assets...'
    }else{
        implementation files(usedClasspath)
    }

    compileOnly project(':annotations')
    annotationProcessor project(':annotations')
    implementation "com.github.Anuken.Arc:arc-core:$arcVersion"
    implementation "com.github.Anuken.Mindustry:core:$mindustryVersion"
}

task rearchive{
    final def listStr = file(assetsDir).list()

    task archDexed(type: Jar){
        if(!dexedJar.exists() || taskNames.contains('main:dex')) ':main:dex'

        archiveFileName.set dexedJar.getName()
        from files(assetsDir){ exclude 'sprites/vanilla/**' }

        from(zipTree(dexedJar)){
            for(final def list : listStr) exclude "$list/**"
        }

        duplicatesStrategy = DuplicatesStrategy.EXCLUDE
        doLast{
            new Fi(dexedJar).writeBytes(new Fi(file(archiveFile.get())).readBytes())
        }
    }

    task archDist(type: Jar){
        if(!distJar.exists() || taskNames.contains('main:deploy')) ':main:deploy'

        archiveFileName.set distJar.getName()
        from files(assetsDir){ exclude 'sprites/vanilla/**' }

        from(zipTree(distJar)){
            for(final def list : listStr) exclude "$list/**"
        }

        duplicatesStrategy = DuplicatesStrategy.EXCLUDE
        doLast{
            new Fi(distJar).writeBytes(new Fi(file(archiveFile.get())).readBytes())
        }
    }

    def finalize = []
    if(distJar.exists() || taskNames.contains('main:deploy')) finalize += archDist
    if(dexedJar.exists() || taskNames.contains('main:dex')) finalize += archDexed

    finalizedBy finalize
}

task proc(dependsOn: [classes, configurations.runtimeClasspath]){
    if(toolRearchive){
        finalizedBy tasks.rearchive
        if(taskNames.contains('tools:proc')) println '.jar files will be re-archived after processing sprites.'
    }

    doLast{
        delete{ delete spritesDir }
        spritesDir.mkdirs()

        copy{
            from spritesRawDir
            into spritesDir
        }

        javaexec{
            workingDir = assetsDir
            main = rootProject.ext.modName.replaceAll("-", "") + '.tools.Tools'
            classpath = sourceSets.main.runtimeClasspath
            systemProperty 'currentModName', modName
        }
    }
}

task updateBundles{
    doLast{
        def uniEscape = { String string ->
            StringBuilder outBuffer = new StringBuilder()
            int len = string.length()
            for(int i = 0; i < len; i++){
                char ch = string.charAt(i)
                if((ch > 61) && (ch < 127)){
                    outBuffer.append(ch == (char)'\\' ? "\\\\" : ch)
                    continue
                }

                if(ch >= 0xE000 && ch <= 0xF8FF){
                    String hex = Integer.toHexString((int)ch)
                    outBuffer.append("\\u")
                    for(int j = 0; j < 4 - hex.length(); j++){
                        outBuffer.append('0')
                    }
                    outBuffer.append(hex)
                }else{
                    outBuffer.append(ch)
                }
            }

            return outBuffer.toString()
        }

        OrderedMap<String, String> base = new OrderedMap<>()
        PropertiesUtils.load(base, Fi.get("main/assets/bundles/bundle.properties").reader())

        //map of line number to comment (or just empty string for blank line) content
        IntMap<String> commentAndBlankLines = new IntMap<>()
        var lines = Fi.get("main/assets/bundles/bundle.properties").reader().readLines()
        int offset = 0
        for(int i = 0; i < lines.size(); i++){
            var line = lines.get(i)
            if(i > 0 && lines.get(i - 1).endsWith("\\")) offset++ //multiline value escaped with \\ at end of line
            else if(line.isEmpty() || line.startsWith("#")) commentAndBlankLines.put(i - offset, line)
        }

        Log.info("Updating bundles...")

        Fi.get("main/assets/bundles").walk(child -> {
            if(child.name() == "bundle.properties" || child.toString().contains("output")) return
            if(project.hasProperty("bundle") && child.name() != project.property("bundle")) return

            Log.info("| @", child.nameWithoutExtension())

            OrderedMap<String, String> other = new OrderedMap<>()

            ObjectMap<String, String> extras = new OrderedMap<>()
            Seq<String> removals = new Seq<>()

            PropertiesUtils.load(other, child.reader())

            for(String key : other.orderedKeys()){
                if(!base.containsKey(key) && key.contains(".details") && false){
                    extras.put(key, other.get(key))
                }else if(!base.containsKey(key)){
                    removals.add(key)
                    Log.info("&lr- Removing unused key '@'...", key)
                }
            }
            if(removals.size > 0) Log.info("&lr@ keys removed.", removals.size)
            for(String s : removals){
                other.remove(s)
            }

            int added = 0

            for(String key : base.orderedKeys()){
                if(other.get(key) == null || other.get(key).trim().isEmpty()){
                    other.put(key, base.get(key))
                    added++
                    Log.info("&lc- Adding missing key '@'...", key)
                }
            }

            Func2<String, String, String> processor = (key, value) ->
                    (key + " =" + (value.trim().isEmpty() ? "" : " ") + uniEscape(value)).replace("\n", "\\n") + "\n"
            Fi output = child.sibling("output/" + child.name())

            if(added > 0) Log.info("&lc@ keys added.", added)
            if(removals.size + added > 0) Log.info("Writing bundle to @", output)
            StringBuilder result = new StringBuilder()

            int i = 0
            //add everything ordered
            for(String key : base.orderedKeys().copy().add(extras.keys().toSeq())){
                //append any comments or blank lines as needed to match the english bundle
                while(commentAndBlankLines.containsKey(i++)) result.append(commentAndBlankLines.get(i - 1) + "\n")
                if(other.get(key) == null) continue

                result.append(processor.get(key, other.get(key)))
                other.remove(key)
            }

            child.writeString(result.toString())
        })
    }
}
