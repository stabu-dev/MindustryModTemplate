plugins{
    id 'java-library'
}

sourceSets.main{
    java.srcDirs = [
        'src/',
        "${compileJava.temporaryDir}/fetched",
        "$buildDir/generated/sources/annotationProcessor/java/main/"
    ]
}

sourceCompatibility = 17
targetCompatibility = 8

dependencies{

    compileOnly "com.github.Anuken.Arc:arc-core:$arcVersion"
    compileOnly "com.github.Anuken.Mindustry:core:$mindustryVersion"
    compileOnly project(':annotations')
    annotationProcessor project(':annotations')
    annotationProcessor "com.github.Anuken:jabel:$jabelVersion"
}

ext{
    fetchPackage = 'template/fetched'
    fetchDir = file("${compileJava.temporaryDir}/fetched/$fetchPackage")
    fetchTemp = file("${compileJava.temporaryDir}/fetch.txt")
    fetchRevision = 0
}

import arc.files.*
import arc.func.*
import arc.util.*
import arc.util.serialization.*

import java.util.concurrent.*
import java.util.concurrent.atomic.*

task deploy(type: Jar, dependsOn: configurations.runtimeClasspath){
    if(!spritesDir.exists()){
        finalizedBy ':tools:proc'
        if(taskNames.contains('main:deploy')) println 'Sprites folder not found; automatically generating sprites...'
    }

    archiveFileName.set "${modName}Desktop.jar"

    from files(sourceSets.main.output.classesDirs)
    from files(sourceSets.main.output.resourcesDir)
    from configurations.runtimeClasspath.collect{ it.isDirectory() ? it : zipTree(it) }
    from files(assetsDir){ exclude 'sprites/vanilla/**' }

    from(rootDir){
        include 'mod.json'
        include 'icon.png'
    }
}

task dex(type: Jar){
    archiveFileName.set "${modName}.jar"

    final def desktopJar = deploy.archiveFile.get().asFile
    final def dexJar = new File(dex.temporaryDir, 'Dexed.jar')

    if(!desktopJar.exists() || taskNames.contains('main:deploy')) dependsOn deploy
    doFirst{
        println 'Dexifying...'
        def command = ['d8', '--min-api', sdkAPI, '--output', dexJar, desktopJar]
        final File[] files =
            configurations.compileClasspath.asList() +
            configurations.runtimeClasspath.asList()

        for(def file : files) command += ['--classpath', file.path]
        command += ['--lib', file("$sdkRoot/platforms/android-$sdkVersion/android.jar")]

        if(OS.isWindows) command = ['cmd', '/c'] + command
        command.join(' ').execute(null, new File("$buildDir/libs")).waitForProcessOutput(System.out, System.err)
    }

    from zipTree(desktopJar)
    from zipTree(dexJar)
}

task dmove(dependsOn: deploy){
    doLast{
        copy{
            from "build/libs/TemplateDesktop.jar"
            into System.getenv("destination")
        }
    }
}

class Fetcher{
    UnsafeRunnable run

    private volatile Throwable error = null

    @SuppressWarnings('all')
    void execute(){
        Boolf<UnsafeRunnable> exec = { final UnsafeRunnable run ->
            try{
                run.run()
                error = null
            }catch(Throwable e){
                Log.err(e)
                error = e
            }

            return error != null
        }

        exec.get(run)
    }
}

task fetchComps{
    doFirst{
        fetchDir.mkdirs()

        final List<Map<String, String>> componentsToDownload = []

        println "Fetching component list from GitHub API..."
        try {
            Http.get("https://api.github.com/repos/Anuken/Mindustry/contents/core/src/mindustry/entities/comp?ref=$mindustryFetchVersion")
                    .error({ final t -> throw new RuntimeException("Failed to list components from GitHub API. URL: https://api.github.com/repos/Anuken/Mindustry/contents/core/src/mindustry/entities/comp?ref=$mindustryFetchVersion", t) })
                    .block({ final res ->
                        final def list = Jval.read(res.getResultAsString()).asArray()
                        println "API returned ${list.size()} potential entity components."

                        for(final Jval val : list){
                            final def filename = val.get('name').asString()
                            final def fileurl = val.get('download_url').asString()

                            if (Fi.get("$fetchDir/$filename").exists()) {
                                println "Already Fetched: $filename. Run cleanFetched to re-fetch."
                            } else {
                                componentsToDownload.add([name: filename, url: fileurl])
                            }
                        }
                    })
        } catch (Exception e) {
            Log.err("Error during GitHub API call to list components:", e)
            throw new GradleException("Could not retrieve component list from GitHub.", e)
        }


        if (componentsToDownload.isEmpty()) {
            println "No new components to fetch (all existing or API returned empty list)."
            fetchTemp.text = "$mindustryVersion/$fetchRevision"
            return
        }

        println "Attempting to fetch ${componentsToDownload.size()} new components."

        int numThreads = Math.min(componentsToDownload.size(), 8)
        if (numThreads <= 0 && componentsToDownload.size() > 0) numThreads = 1

        ExecutorService executor = Executors.newFixedThreadPool(numThreads)
        List<Future<?>> futures = new ArrayList<>()
        final AtomicInteger SucceededCount = new AtomicInteger(0)
        final AtomicInteger FailedCount = new AtomicInteger(0)

        for (final Map<String, String> compInfo : componentsToDownload) {
            futures.add(executor.submit({
                try {
                    println "Fetching ${compInfo.name} from ${compInfo.url}"
                    Http.get(compInfo.url)
                            .error({ final t -> throw new RuntimeException("HTTP error downloading ${compInfo.name} from ${compInfo.url}", t) })
                            .block({ final compRes ->
                                String content = compRes.getResultAsString()
                                        .replace('mindustry.entities.comp', fetchPackage.replace('/', '.'))
                                        .replace('mindustry.annotations.Annotations.*', 'template.annotations.Annotations.*')
                                        .replaceAll('@Component\\((base = true|.)+\\)\n*', '@EntityComponent(base = true, write = false)\n')
                                        .replaceAll('@Component\n*', '@EntityComponent(write = false)\n')
                                        .replaceAll('@BaseComponent\n*', '@EntityBaseComponent\n')
                                        .replaceAll('@CallSuper\n*', '')
                                        .replaceAll('@Final\n*', '')
                                        .replaceAll('@EntityDef\\(*.*\\)*\n*', '')
                                        .replaceAll('@MethodPriority\\(([^)]+)f\\)', '@MethodPriority($1)')

                                if(content.isEmpty()) throw new IllegalStateException("Content for ${compInfo.name} became empty after processing.")

                                final def fi = Fi.get("$fetchDir/${compInfo.name}")
                                fi.writeString(content, false)
                                SucceededCount.incrementAndGet()
                                println "Successfully fetched and processed: ${compInfo.name}"
                            })
                } catch (Throwable t) {
                    FailedCount.incrementAndGet()
                    Log.err("Failed to fetch/process component ${compInfo.name}:", t)
                    throw t
                }
            } as Runnable))
        }

        executor.shutdown()

        List<Throwable> exceptions = []
        for (Future<?> future : futures) {
            try {
                future.get(2, TimeUnit.MINUTES)
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt()
                exceptions.add(new RuntimeException("Fetching was interrupted for one component.", e))
            } catch (ExecutionException e) {
                exceptions.add(e.getCause() != null ? e.getCause() : e)
            } catch (TimeoutException e) {
                exceptions.add(new RuntimeException("Fetching timed out for one component.", e))
            }
        }

        try {
            if (!executor.awaitTermination(30, TimeUnit.SECONDS)) {
                Log.warn("Fetcher executor did not terminate in 30 seconds, attempting forceful shutdown.")
                executor.shutdownNow()
                if (!executor.awaitTermination(30, TimeUnit.SECONDS)) {
                    Log.err("Fetcher executor did not terminate even after forceful shutdown.")
                }
            }
        } catch (InterruptedException ignored) {
            executor.shutdownNow()
            Thread.currentThread().interrupt()
        }

        println "Fetching complete. Succeeded: ${SucceededCount.get()}, Failed: ${FailedCount.get()} (out of ${componentsToDownload.size()} new components attempted)."

        if (!exceptions.isEmpty()) {
            println "Encountered ${exceptions.size()} errors during fetch operations:"
            exceptions.eachWithIndex { Throwable e, int i ->
                Log.err("Error ${i + 1}:", e)
            }
            throw new GradleException("Failed to fetch all components. ${exceptions.size()} errors occurred. Check logs.")
        }

        if (FailedCount.get() > 0) {
            throw new GradleException("Failed to fetch ${FailedCount.get()} components. Check logs.")
        }

        fetchTemp.text = "$mindustryVersion/$fetchRevision"
        println "Wrote ${SucceededCount.get()} new entity components."
    }
}

task cleanFetched(type: Delete){
    delete "$fetchDir"
    delete "$projectDir/fetched"
    delete "$fetchTemp"
}

task assetsJar(type: Jar){
    archiveClassifier.set 'assets'
    from files('assets/')
}

artifacts{
    archives assetsJar
}

tasks.withType(JavaCompile){
    if(!fetchDir.exists() || !fetchTemp.exists()){
        dependsOn fetchComps
    }else{
        String[] content = fetchTemp.text.split('/')
        String ver = content[0]
        String rev = content[1]

        if(ver != "$mindustryVersion" as String || rev != Integer.toString(fetchRevision as int)){
            dependsOn fetchComps
        }
    }

    options.compilerArgs += ['--release', '8']
}

tasks.withType(Jar){
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE

    exclude 'template/fetched/**'
    exclude 'template/entities/comp/**'
    exclude 'template/entities/merge/**'

    exclude 'sprites/vanilla/**'
}
